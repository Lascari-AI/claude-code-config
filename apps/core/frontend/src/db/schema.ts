/**
 * AUTO-GENERATED by drizzle-kit pull â€” DO NOT EDIT manually.
 *
 * Schema ownership: Python/SQLModel in session_db/models.py
 * Type aliases live in ./types.ts (survives pull overwrites).
 *
 * To regenerate: DATABASE_URL="..." npx drizzle-kit pull
 */

import { pgTable, varchar, uniqueIndex, index, uuid, json, timestamp, foreignKey, text, boolean, integer, doublePrecision } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const alembicVersion = pgTable("alembic_version", {
	versionNum: varchar("version_num", { length: 32 }).primaryKey().notNull(),
});

export const projects = pgTable("projects", {
	id: uuid().primaryKey().notNull(),
	name: varchar().notNull(),
	slug: varchar().notNull(),
	path: varchar().notNull(),
	repoUrl: varchar("repo_url"),
	status: varchar().notNull(),
	onboardingStatus: json("onboarding_status"),
	metadata: json(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
}, (table) => [
	uniqueIndex("ix_projects_slug").using("btree", table.slug.asc().nullsLast().op("text_ops")),
	index("ix_projects_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
]);

export const sessions = pgTable("sessions", {
	id: uuid().primaryKey().notNull(),
	sessionSlug: varchar("session_slug").notNull(),
	title: varchar(),
	description: text(),
	projectId: uuid("project_id"),
	status: varchar().notNull(),
	currentPhase: varchar("current_phase").notNull(),
	sessionType: varchar("session_type").notNull(),
	phaseHistory: json("phase_history"),
	workingDir: varchar("working_dir").notNull(),
	sessionDir: varchar("session_dir"),
	gitWorktree: varchar("git_worktree"),
	gitBranch: varchar("git_branch"),
	gitBaseBranch: varchar("git_base_branch"),
	specExists: boolean("spec_exists").notNull(),
	planExists: boolean("plan_exists").notNull(),
	checkpointsTotal: integer("checkpoints_total").notNull(),
	checkpointsCompleted: integer("checkpoints_completed").notNull(),
	checkpointsCompletedList: json("checkpoints_completed_list"),
	currentCheckpoint: integer("current_checkpoint"),
	totalInputTokens: integer("total_input_tokens").notNull(),
	totalOutputTokens: integer("total_output_tokens").notNull(),
	totalCost: doublePrecision("total_cost").notNull(),
	errorMessage: text("error_message"),
	errorPhase: varchar("error_phase"),
	commitsList: json("commits_list"),
	artifacts: json(),
	metadata: json(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	startedAt: timestamp("started_at", { mode: 'string' }),
	completedAt: timestamp("completed_at", { mode: 'string' }),
}, (table) => [
	index("ix_sessions_current_phase").using("btree", table.currentPhase.asc().nullsLast().op("text_ops")),
	index("ix_sessions_project_id").using("btree", table.projectId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("ix_sessions_session_slug").using("btree", table.sessionSlug.asc().nullsLast().op("text_ops")),
	index("ix_sessions_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.projectId],
			foreignColumns: [projects.id],
			name: "sessions_project_id_fkey"
		}),
]);

export const agents = pgTable("agents", {
	id: uuid().primaryKey().notNull(),
	sessionId: uuid("session_id").notNull(),
	agentType: varchar("agent_type").notNull(),
	name: varchar(),
	sdkSessionId: varchar("sdk_session_id"),
	model: varchar().notNull(),
	modelAlias: varchar("model_alias"),
	systemPrompt: text("system_prompt"),
	workingDir: varchar("working_dir"),
	status: varchar().notNull(),
	checkpointId: integer("checkpoint_id"),
	taskGroupId: varchar("task_group_id"),
	inputTokens: integer("input_tokens").notNull(),
	outputTokens: integer("output_tokens").notNull(),
	cost: doublePrecision().notNull(),
	errorMessage: text("error_message"),
	allowedTools: text("allowed_tools"),
	metadata: json(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	startedAt: timestamp("started_at", { mode: 'string' }),
	completedAt: timestamp("completed_at", { mode: 'string' }),
}, (table) => [
	index("ix_agents_agent_type").using("btree", table.agentType.asc().nullsLast().op("text_ops")),
	index("ix_agents_sdk_session_id").using("btree", table.sdkSessionId.asc().nullsLast().op("text_ops")),
	index("ix_agents_session_id").using("btree", table.sessionId.asc().nullsLast().op("uuid_ops")),
	index("ix_agents_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.sessionId],
			foreignColumns: [sessions.id],
			name: "agents_session_id_fkey"
		}),
]);

export const agentLogs = pgTable("agent_logs", {
	id: uuid().primaryKey().notNull(),
	agentId: uuid("agent_id").notNull(),
	sessionId: uuid("session_id").notNull(),
	sdkSessionId: varchar("sdk_session_id"),
	eventCategory: varchar("event_category").notNull(),
	eventType: varchar("event_type").notNull(),
	content: text(),
	payload: json(),
	summary: text(),
	toolName: varchar("tool_name"),
	toolInput: text("tool_input"),
	toolOutput: text("tool_output"),
	entryIndex: integer("entry_index"),
	checkpointId: integer("checkpoint_id"),
	timestamp: timestamp({ mode: 'string' }).notNull(),
	durationMs: integer("duration_ms"),
}, (table) => [
	index("ix_agent_logs_agent_id").using("btree", table.agentId.asc().nullsLast().op("uuid_ops")),
	index("ix_agent_logs_event_category").using("btree", table.eventCategory.asc().nullsLast().op("text_ops")),
	index("ix_agent_logs_event_type").using("btree", table.eventType.asc().nullsLast().op("text_ops")),
	index("ix_agent_logs_session_id").using("btree", table.sessionId.asc().nullsLast().op("uuid_ops")),
	index("ix_agent_logs_timestamp").using("btree", table.timestamp.asc().nullsLast().op("timestamp_ops")),
	index("ix_agent_logs_tool_name").using("btree", table.toolName.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.agentId],
			foreignColumns: [agents.id],
			name: "agent_logs_agent_id_fkey"
		}),
	foreignKey({
			columns: [table.sessionId],
			foreignColumns: [sessions.id],
			name: "agent_logs_session_id_fkey"
		}),
]);

export const interactiveMessages = pgTable("interactive_messages", {
	id: uuid().primaryKey().notNull(),
	sessionId: uuid("session_id").notNull(),
	agentId: uuid("agent_id"),
	phase: varchar().notNull(),
	role: varchar().notNull(),
	blockType: varchar("block_type").notNull(),
	content: text(),
	toolName: varchar("tool_name"),
	turnIndex: integer("turn_index").notNull(),
	blockIndex: integer("block_index").notNull(),
	timestamp: timestamp({ mode: 'string' }).notNull(),
}, (table) => [
	index("ix_interactive_messages_agent_id").using("btree", table.agentId.asc().nullsLast().op("uuid_ops")),
	index("ix_interactive_messages_phase").using("btree", table.phase.asc().nullsLast().op("text_ops")),
	index("ix_interactive_messages_session_id").using("btree", table.sessionId.asc().nullsLast().op("uuid_ops")),
	index("ix_interactive_messages_timestamp").using("btree", table.timestamp.asc().nullsLast().op("timestamp_ops")),
	index("ix_interactive_messages_tool_name").using("btree", table.toolName.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.agentId],
			foreignColumns: [agents.id],
			name: "interactive_messages_agent_id_fkey"
		}),
	foreignKey({
			columns: [table.sessionId],
			foreignColumns: [sessions.id],
			name: "interactive_messages_session_id_fkey"
		}),
]);
